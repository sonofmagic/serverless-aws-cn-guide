# lambda nodejs 函数打包最佳实践

## 前言

本文章的思路，继承发展自这两篇文章:

- [serverless 降低冷启动时间的探索 - 服务端打包 node_modules](https://zhuanlan.zhihu.com/p/407434947)
- [Nodejs云函数冷启动时间的优化](https://zhuanlan.zhihu.com/p/429597900)

这里要感谢这`2`篇文章的作者:[`ice breaker`](https://www.zhihu.com/people/richard-40-19-41)，`2`年前就提供了这么优秀的思路和解决方案了，真是忍不住给他点赞呀。

## 打包服务端 js

回到正题，为什么要去打包服务端 `js`? 用 `layer` 的方式不是蛮好吗？

首先一点，函数冷启动的时间，是和整体运行的代码以及其依赖的大小，是息息相关的。

比如上篇文章中的示例，我们把 `uuid` 这个依赖给做成 `layer` 上传了上去，但是你有没有想过，既然 `uuid` 的所有实现都是 `js`，为什么不把它整个源代码，打入我们的函数构建产物中呢？这样还省了依赖一个 `layer` 呢。

同样的道理，我们函数也可以把 `express`,`lodash` 等等依赖，全部打入我们的函数包里去，以减小整体代码包的体积。

这就像我们在写前端项目那样，本质上也会把所有运行时代码，全部给 `inline` 到各个 `js` 里面去，毕竟浏览器可没有什么 `node_modules` 的加载机制。你写 `vue` 写 `react` 都是直接 `node-resolve` 所有代码的。

## 进一步封装的打包工具

要是在过去，我的实现方式肯定是 `rollup` 或者 `esbuild`，

不过现在有了基于它们更进一步的打包工具: `tsup`/`unbuild`

其中 `unbuild` 我们会在 `monorepo` 章节中介绍它，这里我们主要来介绍 `tsup` 在函数打包中的用法。

`tsup` 本身的打包，主要是基于约定的

比如它会默认去 `inline` 我们所有在运行时引用的，但是却是注册在 `devDependencies` 里的包

而 `dependencies` 里的包，则是被默认加入了 `external` 中，不进行 `node resolve`

简洁的配置文件见下：

```ts
// tsup.config.ts
import { defineConfig } from 'tsup'
const isDev = process.env.NODE_ENV === 'development'
export default defineConfig({
  entry: ['src/index.ts'],
  splitting: false,
  sourcemap: isDev,
  clean: true,
  // external: []
})
```

`package.json` 里的 `npm scripts`

```json
  "scripts": {
    "dev": "cross-env NODE_ENV=development tsup --watch",
    "build": "cross-env NODE_ENV=production tsup",
  },
```

## 完整示例及文章仓库地址

<https://github.com/sonofmagic/serverless-aws-cn-guide>

如果你遇到什么问题，或者发现什么勘误，欢迎提 `issue` 给我
